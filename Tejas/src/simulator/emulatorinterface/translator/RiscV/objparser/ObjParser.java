/*****************************************************************************
				Tejas Simulator
------------------------------------------------------------------------------------------------------------

   Copyright [2010] [Indian Institute of Technology, Delhi]
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
------------------------------------------------------------------------------------------------------------

	Contributors:  Sunil Kumar :: Shraddha Gupta
 *****************************************************************************/

package emulatorinterface.translator.RiscV.objparser;

import emulatorinterface.DynamicInstructionBuffer;
import emulatorinterface.EmulatorPacketList;
import emulatorinterface.communication.Encoding;
import emulatorinterface.communication.Packet;
import emulatorinterface.translator.InvalidInstructionException;
import emulatorinterface.translator.qemuTranslationCache.TranslatedInstructionCache;
import emulatorinterface.translator.visaHandler.DynamicInstructionHandler;
import emulatorinterface.translator.visaHandler.VisaHandlerSelector;
import emulatorinterface.translator.RiscV.instruction.InstructionClass;
import emulatorinterface.translator.RiscV.instruction.InstructionClassTable;
import emulatorinterface.translator.RiscV.instruction.RiscVStaticInstructionHandler;
import emulatorinterface.translator.RiscV.operand.OperandTranslator;
import emulatorinterface.translator.RiscV.registers.Registers;
import emulatorinterface.translator.RiscV.registers.TempRegisterNum;
import generic.GenericCircularQueue;
import generic.Instruction;
import generic.InstructionList;
import generic.InstructionTable;
import generic.Operand;
import generic.OperationType;
import generic.Statistics;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import config.EmulatorConfig;
import config.EmulatorType;
import main.CustomObjectPool;
import main.Main;
import misc.Error;
import misc.Numbers;

/**
 * Objparser class contains methods to parse a static executable file and to
 * determine the information of dynamic instructions. The RiscV assembly code
 * generated by objdump utility is first parsed to obtain operation, source
 * operands and destination operand. The RiscV CISC operations are broken down
 * into corresponding simpler micro-operations which follow load-store
 * architecture. We store the linear address of the instruction and the
 * corresponding micro-operations in a hash-table for faster access to
 * instruction information later on..
 * 
 * TODO::Branch predictor accuracy needs to be checked so that it is handled correctly
 * 
 * 
 * @author Shraddha Gupta :: Sunil Kumar 
 */
public class ObjParser
{
	private static InstructionTable ciscIPtoRiscIP = null;
	private static InstructionList staticMicroOpList = null;
	private static InstructionList threadMicroOpsList[] = null;
	
	public static void initializeThreadMicroOpsList(int maxApplicationThreads) {
		threadMicroOpsList = new InstructionList[maxApplicationThreads];
		
		for(int i=0; i<maxApplicationThreads; i++) {
			threadMicroOpsList[i] = new InstructionList(1000);
		}
		System.out.println("initialized threads");
	}
	
	private static DynamicInstructionBuffer[] staticDynamicInstructionBuffers;
	public static void initializeDynamicInstructionBuffer(int maxApplicationThreads) {
		staticDynamicInstructionBuffers = new DynamicInstructionBuffer[maxApplicationThreads];
		
		for(int i=0; i<maxApplicationThreads; i++) {
			staticDynamicInstructionBuffers[i] = new DynamicInstructionBuffer();
		}
		System.out.println("reached here too");
	}
	
	private static Instruction staticLoadMicroOp, staticStoreMicroOp, staticBranchMicroOp;
	public static void initializeControlMicroOps() {
		// Load from immediate memory location to a MSR(load_reg)
		Operand loadLocation = Operand.getMemoryOperand(Operand.getImmediateOperand(), null);
		Operand loadRegister = Operand.getIntegerRegister(Registers.encodeRegister("load_reg"));
		staticLoadMicroOp = Instruction.getLoadInstruction(loadLocation, loadRegister);
		
		// Store from MSR(load_reg) to immediate memory location 
		Operand storeLocation = Operand.getMemoryOperand(Operand.getImmediateOperand(), null);
		Operand storeRegister = Operand.getIntegerRegister(Registers.encodeRegister("store_reg"));
		staticStoreMicroOp = Instruction.getStoreInstruction(storeLocation, storeRegister);
		
		// Branch address
		Operand branchAddress = Operand.getImmediateOperand();
		staticBranchMicroOp = Instruction.getBranchInstruction(branchAddress);
	}
	
	/**
	* This method translates a static instruction to dynamic instruction.
	* It takes as arguments - instructionTable, instructionPointer and dynamic
	* Instruction information
	*/

	/**
	* This method parses the object file, and creates a hash-table from the
	* static instructions.
	* @param executableFile
	* @return
	*/
	public static void buildStaticInstructionTable(String executableFile) 
	{
		BufferedReader input;

		long noOfLines = noOfLines(executableFile);
		if(noOfLines==0) {
			misc.Error.showErrorAndExit("error in reading the output of objdump on " + executableFile);
		}

		// Read the assembly code from the program using object-dump utility
		input = readObjDumpOutput(executableFile);

		// Create a new hash table
		ciscIPtoRiscIP = new InstructionTable((int)noOfLines);

		System.out.println("The executable has " + noOfLines + " assembly lines");
		
		String line;
		long ProgramCounter;
		String operation;
		String operand1, operand2, operand3;
		
		staticMicroOpList = new InstructionList((int)noOfLines*3);
		
		int microOpsIndex = 0;
		
		long handled = 0, notHandled = 0;
		
		// Read from the obj-dump output
		while ((line = readNextLineOfObjDump(input)) != null) 
		{
			
			if (!(isContainingObjDumpAssemblyCode(line))) {
				continue;
			}

			String assemblyCodeTokens[] = tokenizeObjDumpAssemblyCode(line);

			// read the assembly code tokens
			ProgramCounter = Numbers.hexToLong(assemblyCodeTokens[0]);
			operation = assemblyCodeTokens[2];
			operand1 = assemblyCodeTokens[3];
			operand2 = assemblyCodeTokens[4];
			operand3 = assemblyCodeTokens[5];
			// Riscify current instruction
			int microOpsIndexBefore = microOpsIndex;
			int numRicscInsn = riscifyInstruction( ProgramCounter,operation, 
					operand1, operand2, operand3, 
					staticMicroOpList);
			microOpsIndex += numRicscInsn;
			//riscifyInstruction has a problem it does not update microOpsIndex
			if(microOpsIndexBefore==microOpsIndex) {
				notHandled++;
			} else {
				handled++;
			}

			// add instruction's index into the hash-table
			ciscIPtoRiscIP.addInstruction(ProgramCounter, microOpsIndexBefore);
		}
		System.out.println("handled:  "+handled);
		System.out.println("Total number of assembly lines = " + (handled + notHandled)); 
		System.out.println("Total number of micro-operations = " + staticMicroOpList.length());

		// close the buffered reader
		try {input.close();}
		catch (IOException ioe) {Error.showErrorAndExit("\n\tError in closing the buffered reader !!");}

		Statistics.setStaticCoverage(((double)handled/(double)(handled+notHandled))*(double)100);
	}

	private static int riscifyInstruction(
			long ProgramCounter, String operation, 
			String operand1Str, String operand2Str, String operand3Str, 
			InstructionList instructionList) 
	{
		int var =0;

		int microOpsIndexBefore = instructionList.length();
		Operand operand1 = null, operand2 = null, operand3 = null;
		
		try
		{
			//Determine the instruction class for this instruction
			InstructionClass instructionClass;
			instructionClass = InstructionClassTable.getInstructionClass(operation);
			// Obtain a handler for this instruction
			RiscVStaticInstructionHandler handler;
			var = 1;
			handler = InstructionClassTable.getInstructionClassHandler(instructionClass);
			// Handle the instruction
			var =2;
			if(handler!=null) {
				// Simplify the operands
	
				TempRegisterNum tempRegisterNum = new TempRegisterNum();
				var =3;
				operand1 = OperandTranslator.simplifyOperand(operand1Str, instructionList, tempRegisterNum);
				var =4;
				operand2 = OperandTranslator.simplifyOperand(operand2Str, instructionList, tempRegisterNum);
				var = 5;
				operand3 = OperandTranslator.simplifyOperand(operand3Str, instructionList, tempRegisterNum);
				var =6;
				handler.handle(ProgramCounter, operand1, operand2, operand3, instructionList, tempRegisterNum);
				var =7;
				//now set the pc of all converted instructions to ProgramCounter
				for(int i=microOpsIndexBefore; i<instructionList.length(); i++)
				{
					instructionList.setCISCProgramCounter(i, ProgramCounter);
				}
				var = 8;
				}else {
					System.out.println("try :  "+ ProgramCounter+"  :  " +operation+"  :  "+operand1Str+" : "+operand2Str+"  :  "+operand3Str);
				throw new InvalidInstructionException("", false);
			}			
		} catch(Exception inInstrEx) {
			/*
			 * microOps created for this instruction are not valid 
			 * since the translation of the instruction did not 
			 * complete its execution.
			 */
//			System.out.println("catch :  "+var+"  :  "+ ProgramCounter+"  :  " +operation+"  :  "+operand1Str+" : "+operand2Str+"  :  "+operand3Str);
			while(instructionList.getListSize() != microOpsIndexBefore) {
				instructionList.removeLastInstr(operand1, operand2, operand3);
				
			}
     //riscify gives error for unhandled instructions and for negative operands;
		}
		
		return (instructionList.length()-microOpsIndexBefore);
	}

	// runs obj-dump utility on the executable file to obtain the assembly code.
	// The obj-dump output is then returned using a buffered reader.
	private static BufferedReader readObjDumpOutput(String executableFileName) {
		BufferedReader input = null;

		try {
			// Generate the command for reading input file in .gz format
			String command[] = {"zcat", executableFileName };
			Process p = Runtime.getRuntime().exec(command);

			// read the output of the process in a buffered reader
			input = new BufferedReader(
					new InputStreamReader(p.getInputStream()));
		} catch (IOException ioe) {
			Error
					.showErrorAndExit("\n\tError in running objdump on the executable file !!");
		}

		return input;
	}
	
	// Counts number of lines in a file.
	public static int noOfLines(String executableFileName) {
		int numLines = 0;
		BufferedReader input = null;

		try {
			// Generate the command for reading input file in .gz format
			String command[] = {"zcat", executableFileName };
			Process p = Runtime.getRuntime().exec(command);

			// read the output of the process in a buffered reader
			input = new BufferedReader(
					new InputStreamReader(p.getInputStream()));
			
			while((input.readLine())!=null) {
				numLines++;
			}
		} catch (IOException ioe) {
			Error
					.showErrorAndExit("\n\tError in running objdump on the executable file !!");
		}

		return numLines;
	}

	// reads the next line of buffered reader "input"
	private static String readNextLineOfObjDump(BufferedReader input) 
	{
		try 
		{
			return (input.readLine());
		} 
		catch (IOException ioe) 
		{
			Error.showErrorAndExit("\n\tError in reading from the buffered reader containing assembly code !!");
		}

		// we would never reach this statement
		return null;
	}
	
	private static Matcher objdumpAssemblyCodeMatcher;
	public static void createObjdumpAssemblyCodeMatcher()
	{
		Pattern p = Pattern.compile("[0-9a-fA-FxX]+ (.*) [0-9a-zA-Z]+[0-9a-zA-Z(), -]*");
		objdumpAssemblyCodeMatcher = p.matcher("");
	}

	// checks if the passed line of objdump output matches the output for an
	// assembly code.
	private static boolean isContainingObjDumpAssemblyCode(String line) 
	{
		if(objdumpAssemblyCodeMatcher==null) {
			createObjdumpAssemblyCodeMatcher();
		}
		
		// A valid assembly code line has following pattern
		// linear-address operation type opcode (operands)
		return objdumpAssemblyCodeMatcher.reset(line).matches();
	}

	// for a line of assembly code, this would return the
	// linear address, operation, operand1,operand2, operand3
	private static String[] tokenizeObjDumpAssemblyCode(String line) 
	{
		String linearAddress;
		String instructionPrefix;
		String operation;
		String operand1, operand2, operand3;
		String operands;
		
		// Initialise all operands to null
		operands = operand1 = operand2 = operand3 = null;

		// Tokenize the line
		StringTokenizer lineTokenizer = new StringTokenizer(line);

		// Read the tokens into required variables
		linearAddress = lineTokenizer.nextToken();
		lineTokenizer.nextToken(); // skip the referred address
		
		// Determine the instruction prefix and operation
		String tempToken = lineTokenizer.nextToken();
			instructionPrefix = null;
			operation = tempToken;
		
		if (lineTokenizer.hasMoreTokens())
			operands = lineTokenizer.nextToken();

		// If the operation has tokens, then break it further.
		if (operands != null) {
			// First join all the operand tokens
			while (lineTokenizer.hasMoreTokens())
				operands = operands + " " + lineTokenizer.nextToken();

			StringTokenizer operandTokenizer = new StringTokenizer(operands,
					",", false);

			if (operandTokenizer.hasMoreTokens())
				operand1 = operandTokenizer.nextToken();
			if (operandTokenizer.hasMoreTokens())
				operand2 = operandTokenizer.nextToken();
			if (operandTokenizer.hasMoreTokens())
				operand3 = operandTokenizer.nextToken();
		}

		return new String[] { linearAddress, instructionPrefix, operation, operand1, operand2,
				operand3 };
	}
	
	
	// return index of null character for a byte array
	private static int len(byte[] asmBytes) {
		int i=0;
		for(;asmBytes[i]!=0 && i<asmBytes.length;i++);
		return i;
	}
	
	// searches character ch in asmByes. If not-found return -1, else return index of ch
	private static int indexOf(byte[] asmBytes, char ch, int offset, int len) {
		for(int i=offset; i<len(asmBytes); i++) {
			if(asmBytes[i]==ch) {
				return i;
			}
		}
		
		return -1;
	}
	
	private static String concatenateStringArray(String[] strArray) {
		String concatenatedString = new String(strArray[0] + strArray[1] + strArray[2] + strArray[3]);
		return concatenatedString;
	}
	// for  a line of assembly code, this would return the
	// linear address, operation, operand1,operand2, operand3
	private static String[] tokenizeQemuAssemblyCode(byte[] asmBytes) {
		
		String assemblyTokens[] = new String[5];
			
		int previousPointer, currentPointer;
		previousPointer = currentPointer = 0;

		// -------------- instructionPrefix and operation ---------------------------------- 
		currentPointer = indexOf(asmBytes, ' ', previousPointer, 64);
		
		if(currentPointer==-1) {
			assemblyTokens[0] = null;
			assemblyTokens[1] = new String(asmBytes, 0, len(asmBytes)); // only operation field is present
			assemblyTokens[2] = assemblyTokens[3] = assemblyTokens[4] = null;
			return assemblyTokens;
		}
		
		String str = new String(asmBytes, previousPointer, (currentPointer-previousPointer));
		currentPointer++; previousPointer = currentPointer;
			assemblyTokens[0] = null;
			assemblyTokens[1] = str;

		
		// --------------------- operand1, operand2, operand3 --------------------------------
		if(previousPointer==len(asmBytes)) {
			assemblyTokens[2] = assemblyTokens[3] = assemblyTokens[4] = null;
			return assemblyTokens;
		}
		
		currentPointer = indexOf(asmBytes, ',', previousPointer, 64);
		if(currentPointer==-1) {
			assemblyTokens[3] = assemblyTokens[4] = null;
			assemblyTokens[2] = new String(asmBytes, previousPointer, len(asmBytes)-previousPointer);
			return assemblyTokens;
		} 
		else {
			assemblyTokens[2] = new String(asmBytes, previousPointer, (currentPointer-previousPointer));
			currentPointer+=2; previousPointer=currentPointer;
			
			if(previousPointer==len(asmBytes)) {
				assemblyTokens[3] = assemblyTokens[4] = null;
			} else {
				currentPointer = indexOf(asmBytes, ',', previousPointer, 64);
				
				if(currentPointer==-1) {
					assemblyTokens[4] = null;
					assemblyTokens[3] = new String(asmBytes, previousPointer, len(asmBytes)-previousPointer);
					return assemblyTokens;
				} else {
					assemblyTokens[3] = new String(asmBytes, previousPointer, (currentPointer-previousPointer));
					currentPointer++; previousPointer=currentPointer;
					
					assemblyTokens[4] = new String(asmBytes, previousPointer, len(asmBytes)-previousPointer);
					return assemblyTokens;
				}
			}
		}
		
		return assemblyTokens;
	}
	
		
	private static boolean removeInstructionFromTail(GenericCircularQueue<Instruction> inputToPipeline, long ProgramCounter, int previousSize) {
		
		if(inputToPipeline.size()<previousSize) {
			misc.Error.showErrorAndExit("This is not possible !!!");
		}
		
		while(inputToPipeline.size()>previousSize) {
			Instruction ins = inputToPipeline.pop();
			CustomObjectPool.getInstructionPool().returnObject(ins);
		}
		
		return false;
	}

	/*
	 * This function fuses the statically translated micro-ops with the information received from the emulator.
	 * New micro-ops are added to the circular buffer(argument). Finally it returns the number of CISC instructions it could 
	 * translate.
	 */
	static int num =0;
	public static void fuseInstruction(
			int tidApp, long startInstructionPointer,
			EmulatorPacketList arrayListPacket, GenericCircularQueue<Instruction> inputToPipeline)
	{
//		System.out.println(num++);
		int prevLengthOfInputToPipeLine = inputToPipeline.size();

		// Create a dynamic instruction buffer for all control packets
		DynamicInstructionBuffer dynamicInstructionBuffer = staticDynamicInstructionBuffers[tidApp];
		dynamicInstructionBuffer.configurePackets(arrayListPacket);
		
		InstructionList assemblyPacketList = null;
		
		int numCISC = 1;
		int microOpIndex = -1;
		
		boolean removedFromTail = false;		
		// Riscify the assembly packets
		if(EmulatorConfig.emulatorType==EmulatorType.none) 
		{
			assemblyPacketList = threadMicroOpsList[tidApp];
			threadMicroOpsList[tidApp].clear();
			
			//This is a bug(at least in case of caching): assemblyPacketList = threadMicroOpsList[tidApp]; 
			Packet p = arrayListPacket.get(0);
			
			if(p.value==Encoding.ASSEMBLY) {   
 				byte asmBytes[] = CustomObjectPool.getCustomAsmCharPool().dequeue(tidApp);
// 				System.out.println(asmBytes);
				String assemblyTokens[] = tokenizeQemuAssemblyCode(asmBytes);
				String asmText = concatenateStringArray(assemblyTokens);
				//check if present in translated-instruction cache
				if(TranslatedInstructionCache.isPresent(asmText)) {
					assemblyPacketList = TranslatedInstructionCache.getInstructionList(asmText);
					for(int j=0; j<assemblyPacketList.length(); j++) {
						
						assemblyPacketList.setCISCProgramCounter(j, p.ip);
					}
					
				}
			else {
					long ProgramCounter = p.ip;
					String operation, operand1, operand2, operand3;
					operation = assemblyTokens[1];
					operand1 = assemblyTokens[2]; operand2 = assemblyTokens[3]; operand3 = assemblyTokens[4];
					riscifyInstruction( ProgramCounter, 
					operation,operand1, operand2, operand3, 
						assemblyPacketList);
					//Add to translated-instruction cache
					TranslatedInstructionCache.add(asmText, assemblyPacketList);
//					System.out.println(operation+" : "+operand1+" : "+operand2+" : "+operand3);
					
				}
		    } 
		     else {
				return;
//				misc.Error.showErrorAndExit("First packet to fuse instruction must be assembly packet !!");
			   }
			
			microOpIndex = 0;
			
		} 
		else if (EmulatorConfig.emulatorType==EmulatorType.pin) 
		{

			assemblyPacketList = staticMicroOpList;
			// some function should be there like startinstructionpointer
			microOpIndex = ciscIPtoRiscIP.getMicroOpIndex(startInstructionPointer);
			if((microOpIndex==-1) || 
			  (assemblyPacketList.get(microOpIndex).getCISCProgramCounter()!=startInstructionPointer)) 
			{
				// Don't worry. even if the micro-op index is incorrect, it will be caught in the main 
				// translate loop
				microOpIndex = 0;
			}
		}
		
		Instruction staticMicroOp, dynamicMicroOp;
		DynamicInstructionHandler dynamicInstructionHandler;
		type=0;
		// main translate loop.
		while(true)
		{
			staticMicroOp = assemblyPacketList.get(microOpIndex); 

			if(staticMicroOp==null || staticMicroOp.getCISCProgramCounter() != startInstructionPointer) 
			{				
				break;
			}
			dynamicInstructionHandler = VisaHandlerSelector.selectHandler(staticMicroOp.getOperationType());
			dynamicMicroOp = getDynamicMicroOp(staticMicroOp);
			microOpIndex = dynamicInstructionHandler.handle(microOpIndex, dynamicMicroOp, dynamicInstructionBuffer);
			//if microOpIndex equals -1 it means the instruction is of category branch,load or store
			if(microOpIndex==-1)
			{
				if((staticMicroOp.getOperationType()==OperationType.load))
				   type=Values.LOAD;
				else if(staticMicroOp.getOperationType()==OperationType.store)
					type=Values.STORE;
				else
					type=Values.BRANCH;
				CustomObjectPool.getInstructionPool().returnObject(dynamicMicroOp);
				removeInstructionFromTail(inputToPipeline, staticMicroOp.getCISCProgramCounter(), prevLengthOfInputToPipeLine);
				removedFromTail = true;
//					flushDynamicInformationPackets(startInstructionPointer, dynamicInstructionBuffer, inputToPipeline);
				break;
				
			}
			else
			{
				inputToPipeline.enqueue(dynamicMicroOp); 
				//break;//append microOp
				
			}	
		}
		
		if((removedFromTail == true )&& inputToPipeline.size()!=prevLengthOfInputToPipeLine) 
		{
			System.err.println("\ncurrentSize = " + inputToPipeline.size());
			System.err.println("previousSize = " + prevLengthOfInputToPipeLine);
			misc.Error.showErrorAndExit("");
		}
		if(dynamicInstructionBuffer.missedInformation()) {
			flushDynamicInformationPackets(startInstructionPointer,dynamicInstructionBuffer,inputToPipeline);
		}
		
		
	}
	static int type =Values.OTHERS; 
	//Some instructions are not translated by the translator. However, if there are some 
	//load/store/branch operations in this instruction, they must be pushed 
	//to pipeline.
	private static void flushDynamicInformationPackets(
		long ProgramCounter,
		DynamicInstructionBuffer dynamicInstructionBuffer,
		GenericCircularQueue<Instruction> inputToPipeline) 
	{
		
//		System.out.println(num++);
		Instruction dynamicMicroOp;
		DynamicInstructionHandler dynamicInstructionHandler;

		for(int i=dynamicInstructionBuffer.getMemReadCount(); i<dynamicInstructionBuffer.getMemReadSize(); i++)
		{
			dynamicMicroOp = CustomObjectPool.getInstructionPool().borrowObject();
			dynamicMicroOp.copy(staticLoadMicroOp);
			dynamicInstructionHandler = VisaHandlerSelector.selectHandler(dynamicMicroOp.getOperationType());
			dynamicInstructionHandler.handle(0, dynamicMicroOp, dynamicInstructionBuffer);
			inputToPipeline.enqueue(dynamicMicroOp);
		}
				for(int i=dynamicInstructionBuffer.getMemWriteCount(); i<dynamicInstructionBuffer.getMemWriteSize(); i++)
		{
			dynamicMicroOp = CustomObjectPool.getInstructionPool().borrowObject();
			dynamicMicroOp.copy(staticStoreMicroOp);
			dynamicInstructionHandler = VisaHandlerSelector.selectHandler(dynamicMicroOp.getOperationType());
			dynamicInstructionHandler.handle(0, dynamicMicroOp, dynamicInstructionBuffer);
			inputToPipeline.enqueue(dynamicMicroOp);
		}
//		if(type==Values.LOAD)
//		{
//			dynamicMicroOp = CustomObjectPool.getInstructionPool().borrowObject();
//			dynamicMicroOp.copy(staticLoadMicroOp);
//			dynamicInstructionHandler = VisaHandlerSelector.selectHandler(dynamicMicroOp.getOperationType());
//			dynamicInstructionHandler.handle(0, dynamicMicroOp, dynamicInstructionBuffer);
//			inputToPipeline.enqueue(dynamicMicroOp);
//		}
//		if(type==Values.STORE)
//		{
//			dynamicMicroOp = CustomObjectPool.getInstructionPool().borrowObject();
//			dynamicMicroOp.copy(staticStoreMicroOp);
//			dynamicInstructionHandler = VisaHandlerSelector.selectHandler(dynamicMicroOp.getOperationType());
//			dynamicInstructionHandler.handle(0, dynamicMicroOp, dynamicInstructionBuffer);
//			inputToPipeline.enqueue(dynamicMicroOp);
//		}
		// if(type==Values.BRANCH)
		if(dynamicInstructionBuffer.isBranchInformationReadNeeded())
		{
			
			dynamicMicroOp = CustomObjectPool.getInstructionPool().borrowObject();
			dynamicMicroOp.copy(staticBranchMicroOp);
			dynamicInstructionHandler = VisaHandlerSelector.selectHandler(dynamicMicroOp.getOperationType());
			dynamicInstructionHandler.handle(0, dynamicMicroOp, dynamicInstructionBuffer);
			inputToPipeline.enqueue(dynamicMicroOp);
		}
	}

	private static Instruction getDynamicMicroOp(Instruction staticMicroOp) {
		
		Instruction dynamicMicroOp = null;
		
		
		if(EmulatorConfig.emulatorType==EmulatorType.pin) {
			dynamicMicroOp = CustomObjectPool.getInstructionPool().borrowObject();
			dynamicMicroOp.copy(staticMicroOp);
		} else if(EmulatorConfig.emulatorType==EmulatorType.none) { 
			// This will ensure that the packet is returned to instruction pool
			dynamicMicroOp = staticMicroOp;
		}
		
		return dynamicMicroOp;
	}
}
